// Generated by CoffeeScript 1.7.1
(function() {
  var $, regexHelper, url, _, _containsChinese, _getClassAndIdWeight, _getLinkDensity, _isUrl,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  regexHelper = require("./regexHelper");

  $ = require("cheerio");

  _ = require("underscore");

  url = require("url");


  /*
      trim script tag
      @param {String} html html content
   */

  exports.washHtml = function(html) {
    html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    return html;
  };


  /*
      initialize a node with content score
      @param {Object} node
   */

  exports.initializeNode = function(node) {
    var e, score;
    score = 0;
    switch (node.name) {
      case "object":
      case "embed":
        try {
          if (regexHelper.isVideo(node.attribs["src"])) {
            score += 10;
          }
        } catch (_error) {
          e = _error;
          console.dir(e);
        }
        break;
      case "div":
        score += 5;
        break;
      case "pre":
      case "td":
      case "blockquote":
      case "img":
        score += 3;
        break;
      case "address":
      case "ol":
      case "ul":
      case "dl":
      case "dd":
      case "dt":
      case "li":
      case "form":
        score -= 3;
        break;
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
      case "th":
        score -= 5;
    }
    score += _getClassAndIdWeight(node);
    return node.score = score;
  };


  /*
  	get link density
      @param {Object} node
   */

  _getLinkDensity = exports.getLinkDensity = function(node) {
    if (!(node instanceof $)) {
      node = $(node);
    }
    return node.find("a").text().length / node.text();
  };


  /*
      detect input is just some words(more than 5 words)
      @param {String} input
   */

  exports.justWords = function(input) {
    input = input.trim();
    if (_containsChinese(input)) {
      return input.length < 10;
    } else {
      return input.length < 25;
    }
  };


  /*
      calculate content score
      @param {String} input content
   */

  exports.contentScore = function(input) {
    var score;
    score = 1;
    input = input.trim();
    score += input.replace(",", ',').split(',').length;
    if (_containsChinese(input)) {
      score + Math.min(Math.floor(input.length / 40), 3);
    } else {
      score + Math.min(Math.floor(input.length / 100), 3);
    }
    return score;
  };


  /*
      kill all breaks
   */

  exports.killBreaks = function(node) {
    return node.html(regexHelper.replaceBreaks(node.html()));
  };


  /*
      clean tag
      @param {Object} node
      @param {String} tag tag name
   */

  exports.clean = function(node, tag) {
    var isEmbed, n, targetArray, _i, _len, _node, _results;
    isEmbed = tag === "object" || tag === "embed";
    targetArray = node.find(tag);
    _results = [];
    for (_i = 0, _len = targetArray.length; _i < _len; _i++) {
      n = targetArray[_i];
      _node = $(n);
      if (isEmbed && regexHelper.isVideo(_node.html())) {
        continue;
      }
      _results.push(_node.remove());
    }
    return _results;
  };


  /*
      clean headers
      @param {Object} node cheerio node
   */

  exports.cleanHeaders = function(node) {
    var header, headerIndex, headers, _i, _results;
    _results = [];
    for (headerIndex = _i = 2; _i <= 3; headerIndex = ++_i) {
      headers = node.find("h" + headerIndex);
      _results.push((function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = headers.length; _j < _len; _j++) {
          header = headers[_j];
          if (_getClassAndIdWeight(header) < 0 || _getLinkDensity(header) > 0.33) {
            _results1.push(header.remove());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.cleanConditionally = function(node, tag) {
    var contentLength, em, embedCount, embeds, imgLength, inputLength, liLength, linkDensity, n, pLength, score, tagList, toRemove, weight, _i, _j, _len, _len1, _n, _results;
    tagList = node.find(tag);
    if (tagList.length > 0) {
      _results = [];
      for (_i = 0, _len = tagList.length; _i < _len; _i++) {
        n = tagList[_i];
        weight = _getClassAndIdWeight(n);
        score = n.score || 0;
        _n = $(n);
        if ((weight + score) < 0) {
          _results.push(_n.remove());
        } else if (_n.text().replace("ï¼Œ", ",").split(',').length < 10) {
          pLength = _n.find("p").length;
          imgLength = _n.find("img").length;
          liLength = _n.find("li").length;
          inputLength = _n.find("input").length;
          embedCount = 0;
          embeds = _n.find("embed");
          for (_j = 0, _len1 = embeds.length; _j < _len1; _j++) {
            em = embeds[_j];
            if (regexHelper.isVideo($(em).attr("src"))) {
              embedCount += 1;
            }
          }
          contentLength = _n.text().length;
          linkDensity = _getLinkDensity(_n);
          toRemove = false;
          if (imgLength > pLength) {
            toRemove = true;
          } else if (liLength > pLength && (tag !== "ul") && (tag !== "ol")) {
            toRemove = true;
          } else if (inputLength > Math.floor(pLength / 3)) {
            toRemove = true;
          } else if (weight < 25 && linkDensity > 0.2) {
            toRemove = true;
          } else if (weight >= 24 && linkDensity > 0.5) {
            toRemove = true;
          } else if ((embedCount === 1 && contentLength < 75) || embedCount > 1) {
            toRemove = true;
          }
          if (toRemove) {
            _results.push(_n.remove());
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };


  /*
      remove extra paragraphs
      @param {Object} node
   */

  exports.removeExtraParagraph = function(node) {
    var embedCount, imgCount, objectCount, para, paragraphs, _i, _len, _n, _results;
    paragraphs = node.find("p");
    _results = [];
    for (_i = 0, _len = paragraphs.length; _i < _len; _i++) {
      para = paragraphs[_i];
      _n = $(para);
      imgCount = _n.find("img").length;
      embedCount = _n.find("embed").length;
      objectCount = _n.find("object").length;
      if (imgCount === 0 && embedCount === 0 && objectCount === 0 && _n.text().trim() === "") {
        _results.push(_n.remove());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };


  /*
      remove the header that doesn't have next siblings
   */

  exports.removeSingleHeader = function(node) {
    var header, headerIndex, headers, _i, _results;
    _results = [];
    for (headerIndex = _i = 1; _i <= 6; headerIndex = ++_i) {
      headers = $(node).find("h" + headerIndex);
      _results.push((function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = headers.length; _j < _len; _j++) {
          header = headers[_j];
          if (_.isNull(header.next) && _.isNull(header.prev)) {
            _results1.push($(header).remove());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };


  /*
      remove attributes
      @param {Object} node cheerio node
   */

  exports.trimAttributes = function(node) {
    var all, attr, n, proAttrs, _i, _len, _results;
    all = node.find("*");
    _results = [];
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      n = all[_i];
      proAttrs = ['srv'];
      if (n.name !== "object" && n.name !== "embed") {
        proAttrs.push('href');
        proAttrs.push('width');
      }
      _results.push((function() {
        var _j, _len1, _ref, _results1;
        _ref = n.attribs;
        _results1 = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          attr = _ref[_j];
          if (__indexOf.call(proAttrs, attr) < 0) {
            _results1.push($(n).removeAttr(attr));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };


  /*
      replace relative path with real path
      @param {Object} node
      @param {String} baseUrl
   */

  exports.pullOutRealPath = function(node, baseUrl) {
    var imgs, links;
    if (baseUrl) {
      imgs = node.find('img');
      imgs.each(function(i, img) {
        var realPath;
        realPath = img.attribs['src'];
        _.each(img.attribs, function(value, key) {
          if (_isUrl(value) && (value !== realPath || (!realPath))) {
            return realPath = value;
          }
        });
        return img.attribs['src'] = _isUrl(realPath) ? realPath : url.resolve(baseUrl, realPath);
      });
      links = node.find('a');
      return links.each(function(i, link) {
        if (link.attribs['href']) {
          return link.attribs['href'] = url.resolve(baseUrl, link.attribs['href']);
        }
      });
    }
  };


  /*
      detect if string contains chinese words
   */

  _containsChinese = function(str) {
    return escape(str).indexOf("%u") !== -1;
  };


  /*
  	calculate node's description(class+id) score
  	@param {Object} node
  	@return {Number} score
   */

  _getClassAndIdWeight = function(node) {
    var className, desc, id, weight;
    weight = 0;
    if (node.attribs) {
      className = node.attribs['class'];
      id = node.attribs["id"];
      desc = className + id;
      if (!desc) {
        return weight;
      }
      if (regexHelper.isNegative(desc)) {
        weight -= 25;
      }
      if (regexHelper.isPositive(desc)) {
        weight += 25;
      }
    }
    return weight;
  };


  /*
      test path is a url
      @param {String} path
   */

  _isUrl = function(path) {
    var urlRegex;
    urlRegex = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    return urlRegex.test(path);
  };

}).call(this);

//# sourceMappingURL=util.map
